1 Как вы можете описать процесс распространения событий в
JavaScript (Event Propagation)? Расскажите о его основных фазах.
Какие есть способы применения знаний о фазах
распространения событий на практике?

Распространение событий — это механизм, определяющий порядок, в котором события (например, клики, нажатия клавиш) обрабатываются элементами DOM-дерева.
Три фазы распространения событий:
1. Фаза захвата (Capturing)
    Событие движется сверху вниз — от window до целевого элемента
    
2. Фаза цели (Target)
    Событие достигает целевого элемента, на котором произошло действие

3. Фаза всплытия (Bubbling)
    Событие движется снизу вверх — от целевого элемента до window

Пример:
Если кликнуть на <button>, который находится внутри <div>, событие пройдет все три фазы:
Захват: window → document → <div> → <button>
Целевая: <button>
Всплытие: <button> → <div> → document → window

Практическое применение знаний о фазах

Делегирование событий (Event Delegation)
Есть список из 100 кнопок, которые появляются и исчезают динамически. Навешивать обработчик на каждую кнопку — неудобно и медленно.
Вместо этого вешаем один обработчик на родителя (например, на <ul> или <div>), а внутри проверяем, по какой именно кнопке кликнули.
Как работает:
Клик по кнопке "всплывает" (bubbling) до родителя.
Родитель ловит событие и проверяет, кто был целевым элементом (e.target).

Остановка "всплытия" (stopPropagation)
При клике на кнопку внутри модального окна не закрывать всё окно, а только выполнять действие кнопки.
Используем e.stopPropagation(), чтобы событие не "всплыло" выше и не сработал обработчик на родителе.

Перехват события на фазе "погружения" (Capturing)
Нужно перехватить клик на родителе до того, как он дойдёт до дочернего элемента.
Вешаем обработчик с параметром { capture: true }.

Контроль порядка выполнения обработчиков
На одной кнопке висит несколько обработчиков. Нужно, чтобы один сработал раньше другого.
Обработчики на фазе Capturing срабатывают раньше, чем на фазе Bubbling.
Можно управлять порядком, используя третий параметр addEventListener.

------------------------------------------------
2 Расскажите, что такое Promise в JavaScript, как он работает, какие
основные состояния у него бывают? Каким еще способом можно
обработать асинхронный код? Какую роль в асинхронности играет
событийный цикл (Event Loop)?

Promise — это объект, который представляет результат асинхронной операции (например, запроса к серверу, таймера, чтения файла).
Он позволяет обрабатывать результат или ошибку, когда операция завершится, не блокируя основной поток выполнения кода.

Promise может находиться в одном из трёх состояний:
Pending - Начальное состояние: операция ещё не завершена.
Fulfilled - Операция завершена успешно, результат доступен через .then().
Rejected - Операция завершена с ошибкой, ошибка доступна через .catch().

Обработка асинхронного кода
a) Promise + .then()/.catch()
```
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Ошибка:', error));
```
b) Async/Await
```
async function loadData() {
  try {
    let response = await fetch('https://api.example.com/data');
    let data = await response.json();
    console.log(data);
  } catch (error) {
    console.error('Ошибка:', error);
  }
}
loadData();
```

Event Loop — это механизм, который управляет выполнением кода в JavaScript, особенно асинхронного.
Пример:
```
console.log('Начало');
setTimeout(() => console.log('Таймаут'), 10);
console.log('Конец');
// Вывод: "Начало", "Конец", "Таймаут"

```
setTimeout отправляет колбэк в Web API, а Event Loop выполняет его только после очистки Call Stack.

------------------------------------------------
3 Что такое ООП, и какие его ключевые принципы вы могли бы
описать? При объяснении приводите примеры. Максимально
подробно расскажите о том, как ООП реализовано в JavaScript.

ООП (Объектно-Ориентированное Программирование) — это подход к программированию, где программа строится как набор объектов, которые взаимодействуют друг с другом.
Простая аналогия: стройка дома не из кирпичей, а из готовых блоков (окна, двери, стены). Каждый блок знает, что он может делать.

Ключевые принципы ООП
	Инкапсуляция - сокрытие внутреннего состояния объекта и предоставление публичного интерфейса для взаимодействия с ним.
```
class User {
  #password; // Приватное поле (ES2022+)

  constructor(name, password) {
    this.name = name;
    this.#password = password;
  }

  getPassword() {
    return this.#password.replace(/./g, '*');
  }
}

const user = new User('Alice', 'secret');
console.log(user.name); // "Alice"
console.log(user.getPassword()); // "******"
console.log(user.#password); // Ошибка: приватное поле
```

	Наследование - механизм, позволяющий создавать новый класс на основе существующего, наследуя его свойства и методы.
```
class Animal {
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log(`${this.name} издаёт звук`);
  }
}

class Dog extends Animal {
  speak() {
    console.log(`${this.name} лает`);
  }
}

const dog = new Dog('Собака');
dog.speak(); // "Собака лает"
```

	Полиморфизм - возможность объектов с одинаковым интерфейсом иметь разную реализацию.
```
class Cat extends Animal {
  speak() {
    console.log(`${this.name} мяукает!`);
  }
}

const animals = [new Dog('Собака'), new Cat('Кошка')];
animals.forEach(animal => animal.speak());
// "Собака лает!"
// "Кошка мяукает!"
```

	Абстракция - сокрытие сложной реализации и предоставление только необходимых свойств и методов.
```
class CoffeeMachine {
  constructor() {
    this.waterAmount = 0;
    this.coffeeAmount = 0;
  }

  // Простой интерфейс
  makeCoffee() {
    this.#heatWater();
    this.#brewCoffee();
    this.#pourIntoCup();
    return "Готовый кофе";
  }

  // Сложная внутренняя логика скрыта
  #heatWater() {
    console.log("Нагреваю воду...");
  }

  #brewCoffee() {
    console.log("Завариваю кофе...");
  }

  #pourIntoCup() {
    console.log("Наливаю в чашку...");
  }
}

// Использование
const machine = new CoffeeMachine();
console.log(machine.makeCoffee()); // Просто получаем кофе
// Не нужно знать КАК он готовится
```

Как ООП реализовано в JavaScript
a) Прототипное наследование
Каждый объект в JavaScript имеет скрытое свойство [[Prototype]] (доступно через __proto__ или Object.getPrototypeOf()). Если свойство или метод не найден в объекте, JavaScript ищет его в прототипе.
Пример:
```
const animal = {
  speak() {
    console.log(`${this.name} издаёт звук`);
  }
};
const dog = {
  name: 'Собака',
  __proto__: animal // Устанавливаем прототип
};
dog.speak(); // "Собака издаёт звук"

```
У dog нет метода speak, но он есть в его прототипе animal.
JavaScript "поднимается" по цепочке прототипов, пока не найдёт метод.

b) Классы (ES6+)
Синтаксис классов — это удобная обёртка над прототипным наследованием. Под капотом всё равно работают прототипы.
```
class User {
  constructor(name) {
    this.name = name;
  }

  greet() {
    console.log(`Привет, ${this.name}!`);
  }
}

const user = new User('Alice');
user.greet(); // "Привет, Alice!"

```

c) Миксины (Mixins)
Паттерн для добавления методов из одного объекта/класса в другой.
Пример:
```
const sayHiMixin = {
  sayHi() {
    console.log(`Привет, ${this.name}!`);
  }
};

Object.assign(User.prototype, sayHiMixin);
const user = new User('Alice');
user.sayHi(); // "Привет, Alice!"
```
d) Композиция
Альтернатива наследованию: объект собирается из других объектов.
Пример:
```
const canWalk = {
  walk() {
    console.log('Иду...');
  }
};

const canSwim = {
  swim() {
    console.log('Плыву...');
  }
};

const person = Object.assign({}, canWalk, canSwim);
person.walk(); // "Иду..."
person.swim(); // "Плыву..."
```
------------------------------------------------
4 Опишите максимально детально, как браузер обрабатывает URL,
начиная с момента его ввода в адресную строку и заканчивая
отображением страницы. Какие технологии позволяют ускорить
процесс? Какие проблемы (безопастность, междоменное
взаимодействие) могут возникать в процессе?

1. Ввод URL 
Браузер не понимает "michat.pw", ему нужен IP-адрес типа 142.251.39.46

2. Проверка кэша 
Браузер → Проверяет кеш → Нашел IP → Готово!

3. DNS-разрешение 
Полный DNS поиск (если не в кеше):

1. Браузер: "Где michat.pw?"
2. DNS-резолвер: "Спрошу у корневого сервера"
3. Корневой сервер: "Спроси у сервера .pw"
4. Сервер .pw: "Спроси у сервера michat.pw" 
5. Сервер michat.pw: "IP = 142.251.39.46"
6. Браузер получает IP

4. TCP/TLS-рукопожатие 
TCP Handshake (как рукопожатие):

Клиент: "Привет!" (SYN)
Сервер: "Привет! Давай общаться" (SYN-ACK)  
Клиент: "Отлично, начинаем" (ACK)

Для HTTPS - дополнительно безопасное рукопожатие с шифрованием. (TLS Handshake)

5. Получение и отображение страницы
	1. Браузер: "Дай мне страницу" (HTTP запрос)
	2. Сервер: "Вот HTML страница" (HTTP ответ)
	3. Браузер читает HTML
	4. Видит "нужны картинки, стили, скрипты"
	5. Запрашивает дополнительные ресурсы
	6. Собирает всё вместе
	7. Показывает готовую страницу

Что ускоряет процесс:
    Кеши - браузер запоминает сайты
    CDN - копии сайта ближе к пользователю
    HTTP/2 - несколько запросов одновременно
    Preload - предзагрузка важных ресурсов

Проблемы и риски в процессе
1. DNS-spoofing: подмена DNS-ответов (перенаправление на вредоносный сайт)
2. MITM-атаки: перехват трафика (например, в открытых Wi-Fi сетях)
3. XSS (Cross-Site Scripting): внедрение вредоносного JavaScript на страницу
4. CSRF (Cross-Site Request Forgery): подделка запросов от имени пользователя
5. CORS (Cross-Origin Resource Sharing): ограничения на междоменные запросы
6. Slowloris-атаки: медленные HTTP-запросы для перегрузки сервера